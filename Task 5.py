# Создание

а = {} # Пустое множество
b = set() #Пустое множество
c = frozenset() # Пустое неизменяемое множество


а = {1, 1.1, а, (1, 1.1), None, True, print} # Множество в котором: целое; вещественное; строковое; кортеж; пустой тип; нулевый тип; встроенная функция.
a = {1, 1.1, [1, 2]} # Обмануть встроенные проверки добавлением списка в кортеж не получится, возникнет ошибка TypeError: unhashable type: 'list'.

a = frozenset({1, 1.1}) # Так создаётся неизменяемое множество


a = [1, 'abc', 1] # Раньше я был списком
set(a) # {1, 'abc'}, Hо 'a' остался списком
b = set('cловo') # {'с', 'л', 'о', 'в'}
c = frozenset('hello') # {'h', 'e', 'l', 'o'}
d = set([1, [2.1], 1]) # Ошибка, внутри есть изменяемый тип

# Добавление

a = {1, 1.1, 'a'}
a.add('привет!') # Теперь в "а" {1, 1.1, 'а',Привет!"}
b = 1
a.add(b) # Так b = 1, то во множество она не добавится, так как там уже есть 1

a = {1, 2, 3}
a.update({5, 2}) # Добавляет значения (объекты), во множество из другого множества. Помним, что во множестве элементы уникальные. Теперь "а" {1, 2, 3, 5}

# Получение

a = {1, 1.1, 'a'}
a[0] # Oшибка. TypeError: 'set' object is not subscriptable

# Изменение

a = {1, 1.1, 'a'}
a[0] = 'a' # Oшибка. TypeError: 'set' object does not support item assignment
а = {1, 2, 3} # Теперь 'а' равно (1, 2, 3}

# Удаление

a = {1, 1.1, 'a'}
del a[0] # Oшибка. ТypeError: 'set' object doesn't support item deletion
del a # Полное удаление переменной "а"

# Удаление (методы)

a = {1, 2, 3}
a.clear() # Очищает множество, делая его пустым. Теперь "а" {}.
a = {1, 2, 3, 4}
а.рор() # 1. Возвращает элемент из множества и удаляет его. Теперь "а" (2, 3, 4).
a.remove(3) # Удаление передаваемого элемента (например 3) из множества. Теперь "а" (2, 4). Если такого элемента не существует, то вызовется ошибка KeyError
a.discard(5) # None. Тоже удаляет значение или объект, но в отличии от remove не вызывает ошибку, если данного значения нет во множестве, а по умолчанию возвращает None. "а" остался (2, 4}.

# Действия с объектами

a = {1, 2, 3}
b = {3, 5, 6}
c = a-b
print(c) # (1, 2) так как из 1, 2, 3 только 1 и 2 нет во множестве "b"
a-= b # Теперь "а" равно {1, 2}

# Методы

help(set) # Информация о множествах
a = {1, 2, 3}
а.сору() # (1, 2, 3). Возвращает копию множества.
a.isdisjoint({4, 5, 6}) # True. Проверяет, что между множествами нет общих элементов.
a.issubset({4, 3, 1, 2}) # True. Проверяет, что множество "а" является подмножеством (находится в) (4, 3, 1, 2).
a.issuperset({2, 1}) # True. Проверяет, что множество "а" является охватывающим множеством (2, 1). Т.е. что {2, 1} содержится в множестве "а".

a = frozenset({1, 2, 3})
a.copy() # (1, 2, 3). Возвращает копию множества.
# И методы isdisjoint, issubset, issuperset как в обычном множестве.

# Специальный метод interselection

a = {'сыр', 'помидор', 'молоко'}
b = {'яблоко', 'хлеб', 'молоко'}
a.intersection(b) # (молоко"). Возвращает множество в котором общее между двумя множествами
a.intersection_update(b) # Записывает в множество "а" результат метода intersection. Теперь "а" (молоко"}

# Специальный метод union

a = {'сыр', 'помидор', 'молоко'}
b = {'яблоко', 'хлеб', 'молоко'}
a.union(b) # ('сыр', 'помидор', 'молоко', 'Яблоко', 'хлеб'). Возвращает множество в котором элементы соединены в одно множество.
a.union_update(b) # Записывает в множество "а" результат метода union. Теперь "а" ('сыр', 'помидор', 'молоко', 'яблоко', 'хлеб')

# Специальный метод difference

a = {'сыр', 'помидор', 'молоко'}
b = {'яблоко', 'хлеб', 'молоко'}
a.difference(b) # ('помидор', 'сыр'). Возвращает множество в котором содержатся только уникальные продукты, которых нев в другом множестве.
a.difference_update(b) # Записывает в множество "а" результат метода difference. Теперь "а" {'помидор', 'сыр'}

# Специальный метод symmetric_difference

a = {'сыр', 'помидор', 'молоко'}
b = {'яблоко', 'хлеб', 'молоко'}
a.symmetric_difference(b) # ('помидор', 'сыр', 'яблоко', 'хлеб'). Возвращает множество со всеми значениями, исключая общее между двумя множествами.
a.symmetric_difference_update(b) # Записывает в множество "а" результат метода symmetric_difference. Теперь "а" (помидор, 'сыр', 'яблоко', 'хлеб')

# Практические моменты

а = {'сыр', 'помидор', 'молоко', 'колбаса'}
b = {'яблоко', 'хлеб', 'молоко', 'огурец'}
c = {'колбаса', 'огурец', 'молоко'} # Общие товары у 3-ёх множеств
a_b = a.intersection(b) # {'молоко'}
a_b_c = a_b.intersection(c) # {'молоко'}
# Запись через последовательный вызов
a.intersection (b).intersection(c) # {'молоко'}.
# Уникальные товары в корзине Ильи
c.difference(b).difference(a) # {}.
# Или можно так
c.difference (b.union(a)) # {}.

